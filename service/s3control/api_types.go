// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package s3control

import (
	"encoding/xml"
	"fmt"
	"strconv"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/internal/awsutil"
	"github.com/aws/aws-sdk-go-v2/private/protocol"
)

var _ aws.Config
var _ = awsutil.Prettify

// A container element for the job configuration and status information returned
// by a Describe Job request.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/JobDescriptor
type JobDescriptor struct {
	_ struct{} `type:"structure"`

	// Indicates whether confirmation is required before Amazon S3 begins running
	// the specified job. Confirmation is required only for jobs created through
	// the Amazon S3 console.
	ConfirmationRequired *bool `type:"boolean"`

	// A timestamp indicating when this job was created.
	CreationTime *time.Time `type:"timestamp"`

	// The description for this job, if one was provided in this job's Create Job
	// request.
	Description *string `min:"1" type:"string"`

	// If the specified job failed, this field contains information describing the
	// failure.
	FailureReasons []JobFailure `type:"list"`

	// The Amazon Resource Name (ARN) for this job.
	JobArn *string `min:"1" type:"string"`

	// The ID for the specified job.
	JobId *string `min:"5" type:"string"`

	// The configuration information for the specified job's manifest object.
	Manifest *JobManifest `type:"structure"`

	// The operation that the specified job is configured to execute on the objects
	// listed in the manifest.
	Operation *JobOperation `type:"structure"`

	// The priority of the specified job.
	Priority *int64 `type:"integer"`

	// Describes the total number of tasks that the specified job has executed,
	// the number of tasks that succeeded, and the number of tasks that failed.
	ProgressSummary *JobProgressSummary `type:"structure"`

	// Contains the configuration information for the job-completion report if you
	// requested one in the Create Job request.
	Report *JobReport `type:"structure"`

	// The Amazon Resource Name (ARN) for the Identity and Access Management (IAM)
	// Role assigned to execute the tasks for this job.
	RoleArn *string `min:"1" type:"string"`

	// The current status of the specified job.
	Status JobStatus `type:"string" enum:"true"`

	StatusUpdateReason *string `min:"1" type:"string"`

	// The reason why the specified job was suspended. A job is only suspended if
	// you create it through the Amazon S3 console. When you create the job, it
	// enters the Suspended state to await confirmation before running. After you
	// confirm the job, it automatically exits the Suspended state.
	SuspendedCause *string `min:"1" type:"string"`

	// The timestamp when this job was suspended, if it has been suspended.
	SuspendedDate *time.Time `type:"timestamp"`

	// A timestamp indicating when this job terminated. A job's termination date
	// is the date and time when it succeeded, failed, or was canceled.
	TerminationDate *time.Time `type:"timestamp"`
}

// String returns the string representation
func (s JobDescriptor) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobDescriptor) MarshalFields(e protocol.FieldEncoder) error {
	if s.ConfirmationRequired != nil {
		v := *s.ConfirmationRequired

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ConfirmationRequired", protocol.BoolValue(v), metadata)
	}
	if s.CreationTime != nil {
		v := *s.CreationTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationTime",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Description", protocol.StringValue(v), metadata)
	}
	if s.FailureReasons != nil {
		v := s.FailureReasons

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "FailureReasons", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.JobArn != nil {
		v := *s.JobArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "JobArn", protocol.StringValue(v), metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "JobId", protocol.StringValue(v), metadata)
	}
	if s.Manifest != nil {
		v := s.Manifest

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Manifest", v, metadata)
	}
	if s.Operation != nil {
		v := s.Operation

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Operation", v, metadata)
	}
	if s.Priority != nil {
		v := *s.Priority

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Priority", protocol.Int64Value(v), metadata)
	}
	if s.ProgressSummary != nil {
		v := s.ProgressSummary

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ProgressSummary", v, metadata)
	}
	if s.Report != nil {
		v := s.Report

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Report", v, metadata)
	}
	if s.RoleArn != nil {
		v := *s.RoleArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RoleArn", protocol.StringValue(v), metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", v, metadata)
	}
	if s.StatusUpdateReason != nil {
		v := *s.StatusUpdateReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StatusUpdateReason", protocol.StringValue(v), metadata)
	}
	if s.SuspendedCause != nil {
		v := *s.SuspendedCause

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SuspendedCause", protocol.StringValue(v), metadata)
	}
	if s.SuspendedDate != nil {
		v := *s.SuspendedDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SuspendedDate",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	if s.TerminationDate != nil {
		v := *s.TerminationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TerminationDate",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	return nil
}
func (s *JobDescriptor) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = JobDescriptor{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "ConfirmationRequired":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.ConfirmationRequired = &value
			case "CreationTime":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := protocol.ParseTime(protocol.ISO8601TimeFormatName, string(v))
				s.CreationTime = &value
			case "Description":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Description = &value
			case "FailureReasons":
				if s.FailureReasons == nil {
					s.FailureReasons = make([]JobFailure, 0)
				}
				err := unmarshalAWSXMLListJobFailureList(&s.FailureReasons, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
			case "JobArn":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.JobArn = &value
			case "JobId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.JobId = &value
			case "Manifest":
				value := JobManifest{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				s.Manifest = &value
			case "Operation":
				value := JobOperation{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				s.Operation = &value
			case "Priority":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.Priority = &value
			case "ProgressSummary":
				value := JobProgressSummary{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				s.ProgressSummary = &value
			case "Report":
				value := JobReport{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				s.Report = &value
			case "RoleArn":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.RoleArn = &value
			case "Status":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := JobStatus(v)
				s.Status = value
			case "StatusUpdateReason":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.StatusUpdateReason = &value
			case "SuspendedCause":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.SuspendedCause = &value
			case "SuspendedDate":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := protocol.ParseTime(protocol.ISO8601TimeFormatName, string(v))
				s.SuspendedDate = &value
			case "TerminationDate":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := protocol.ParseTime(protocol.ISO8601TimeFormatName, string(v))
				s.TerminationDate = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobDescriptor.%s, %s", name, err)
				}
			}
		}
	}
}

// If this job failed, this element indicates why the job failed.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/JobFailure
type JobFailure struct {
	_ struct{} `type:"structure"`

	// The failure code, if any, for the specified job.
	FailureCode *string `min:"1" type:"string"`

	// The failure reason, if any, for the specified job.
	FailureReason *string `min:"1" type:"string"`
}

// String returns the string representation
func (s JobFailure) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobFailure) MarshalFields(e protocol.FieldEncoder) error {
	if s.FailureCode != nil {
		v := *s.FailureCode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FailureCode", protocol.StringValue(v), metadata)
	}
	if s.FailureReason != nil {
		v := *s.FailureReason

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FailureReason", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *JobFailure) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = JobFailure{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML JobFailure.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "FailureCode":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobFailure.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.FailureCode = &value
			case "FailureReason":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobFailure.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.FailureReason = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobFailure.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListJobFailureList(s *[]JobFailure, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]JobFailure, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := JobFailure{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []JobFailure.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []JobFailure.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListJobFailureList(s *[]JobFailure, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]JobFailure, 0)
		}
	}()
	value := JobFailure{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Contains the configuration and status information for a single job retrieved
// as part of a job list.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/JobListDescriptor
type JobListDescriptor struct {
	_ struct{} `type:"structure"`

	// A timestamp indicating when the specified job was created.
	CreationTime *time.Time `type:"timestamp"`

	// The user-specified description that was included in the specified job's Create
	// Job request.
	Description *string `min:"1" type:"string"`

	// The ID for the specified job.
	JobId *string `min:"5" type:"string"`

	// The operation that the specified job is configured to run on each object
	// listed in the manifest.
	Operation OperationName `type:"string" enum:"true"`

	// The current priority for the specified job.
	Priority *int64 `type:"integer"`

	// Describes the total number of tasks that the specified job has executed,
	// the number of tasks that succeeded, and the number of tasks that failed.
	ProgressSummary *JobProgressSummary `type:"structure"`

	// The specified job's current status.
	Status JobStatus `type:"string" enum:"true"`

	// A timestamp indicating when the specified job terminated. A job's termination
	// date is the date and time when it succeeded, failed, or was canceled.
	TerminationDate *time.Time `type:"timestamp"`
}

// String returns the string representation
func (s JobListDescriptor) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobListDescriptor) MarshalFields(e protocol.FieldEncoder) error {
	if s.CreationTime != nil {
		v := *s.CreationTime

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CreationTime",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	if s.Description != nil {
		v := *s.Description

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Description", protocol.StringValue(v), metadata)
	}
	if s.JobId != nil {
		v := *s.JobId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "JobId", protocol.StringValue(v), metadata)
	}
	if len(s.Operation) > 0 {
		v := s.Operation

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Operation", v, metadata)
	}
	if s.Priority != nil {
		v := *s.Priority

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Priority", protocol.Int64Value(v), metadata)
	}
	if s.ProgressSummary != nil {
		v := s.ProgressSummary

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "ProgressSummary", v, metadata)
	}
	if len(s.Status) > 0 {
		v := s.Status

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Status", v, metadata)
	}
	if s.TerminationDate != nil {
		v := *s.TerminationDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TerminationDate",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	return nil
}
func (s *JobListDescriptor) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = JobListDescriptor{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML JobListDescriptor.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "CreationTime":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobListDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := protocol.ParseTime(protocol.ISO8601TimeFormatName, string(v))
				s.CreationTime = &value
			case "Description":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobListDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Description = &value
			case "JobId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobListDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.JobId = &value
			case "Operation":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobListDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := OperationName(v)
				s.Operation = value
			case "Priority":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobListDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.Priority = &value
			case "ProgressSummary":
				value := JobProgressSummary{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobListDescriptor.%s, %s", name, err)
				}
				s.ProgressSummary = &value
			case "Status":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobListDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := JobStatus(v)
				s.Status = value
			case "TerminationDate":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobListDescriptor.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := protocol.ParseTime(protocol.ISO8601TimeFormatName, string(v))
				s.TerminationDate = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobListDescriptor.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListJobListDescriptorList(s *[]JobListDescriptor, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]JobListDescriptor, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := JobListDescriptor{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []JobListDescriptor.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []JobListDescriptor.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListJobListDescriptorList(s *[]JobListDescriptor, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]JobListDescriptor, 0)
		}
	}()
	value := JobListDescriptor{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Contains the configuration information for a job's manifest.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/JobManifest
type JobManifest struct {
	_ struct{} `type:"structure"`

	// Contains the information required to locate the specified job's manifest.
	//
	// Location is a required field
	Location *JobManifestLocation `type:"structure" required:"true"`

	// Describes the format of the specified job's manifest. If the manifest is
	// in CSV format, also describes the columns contained within the manifest.
	//
	// Spec is a required field
	Spec *JobManifestSpec `type:"structure" required:"true"`
}

// String returns the string representation
func (s JobManifest) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *JobManifest) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "JobManifest"}

	if s.Location == nil {
		invalidParams.Add(aws.NewErrParamRequired("Location"))
	}

	if s.Spec == nil {
		invalidParams.Add(aws.NewErrParamRequired("Spec"))
	}
	if s.Location != nil {
		if err := s.Location.Validate(); err != nil {
			invalidParams.AddNested("Location", err.(aws.ErrInvalidParams))
		}
	}
	if s.Spec != nil {
		if err := s.Spec.Validate(); err != nil {
			invalidParams.AddNested("Spec", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobManifest) MarshalFields(e protocol.FieldEncoder) error {
	if s.Location != nil {
		v := s.Location

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Location", v, metadata)
	}
	if s.Spec != nil {
		v := s.Spec

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Spec", v, metadata)
	}
	return nil
}
func (s *JobManifest) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = JobManifest{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML JobManifest.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Location":
				value := JobManifestLocation{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobManifest.%s, %s", name, err)
				}
				s.Location = &value
			case "Spec":
				value := JobManifestSpec{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobManifest.%s, %s", name, err)
				}
				s.Spec = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobManifest.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListJobManifestFieldList(s *[]JobManifestFieldName, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]JobManifestFieldName, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []JobManifestFieldName.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := JobManifestFieldName(v)
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []JobManifestFieldName.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListJobManifestFieldList(s *[]JobManifestFieldName, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]JobManifestFieldName, 0)
		}
	}()
	return nil
}

// Contains the information required to locate a manifest object.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/JobManifestLocation
type JobManifestLocation struct {
	_ struct{} `type:"structure"`

	// The ETag for the specified manifest object.
	//
	// ETag is a required field
	ETag *string `min:"1" type:"string" required:"true"`

	// The Amazon Resource Name (ARN) for a manifest object.
	//
	// ObjectArn is a required field
	ObjectArn *string `min:"1" type:"string" required:"true"`

	// The optional version ID to identify a specific version of the manifest object.
	ObjectVersionId *string `min:"1" type:"string"`
}

// String returns the string representation
func (s JobManifestLocation) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *JobManifestLocation) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "JobManifestLocation"}

	if s.ETag == nil {
		invalidParams.Add(aws.NewErrParamRequired("ETag"))
	}
	if s.ETag != nil && len(*s.ETag) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ETag", 1))
	}

	if s.ObjectArn == nil {
		invalidParams.Add(aws.NewErrParamRequired("ObjectArn"))
	}
	if s.ObjectArn != nil && len(*s.ObjectArn) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ObjectArn", 1))
	}
	if s.ObjectVersionId != nil && len(*s.ObjectVersionId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ObjectVersionId", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobManifestLocation) MarshalFields(e protocol.FieldEncoder) error {
	if s.ETag != nil {
		v := *s.ETag

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ETag", protocol.StringValue(v), metadata)
	}
	if s.ObjectArn != nil {
		v := *s.ObjectArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectArn", protocol.StringValue(v), metadata)
	}
	if s.ObjectVersionId != nil {
		v := *s.ObjectVersionId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectVersionId", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *JobManifestLocation) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = JobManifestLocation{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML JobManifestLocation.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "ETag":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobManifestLocation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ETag = &value
			case "ObjectArn":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobManifestLocation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ObjectArn = &value
			case "ObjectVersionId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobManifestLocation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ObjectVersionId = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobManifestLocation.%s, %s", name, err)
				}
			}
		}
	}
}

// Describes the format of a manifest. If the manifest is in CSV format, also
// describes the columns contained within the manifest.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/JobManifestSpec
type JobManifestSpec struct {
	_ struct{} `type:"structure"`

	// If the specified manifest object is in the S3BatchOperations_CSV_20180820
	// format, this element describes which columns contain the required data.
	Fields []JobManifestFieldName `type:"list"`

	// Indicates which of the available formats the specified manifest uses.
	//
	// Format is a required field
	Format JobManifestFormat `type:"string" required:"true" enum:"true"`
}

// String returns the string representation
func (s JobManifestSpec) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *JobManifestSpec) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "JobManifestSpec"}
	if len(s.Format) == 0 {
		invalidParams.Add(aws.NewErrParamRequired("Format"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobManifestSpec) MarshalFields(e protocol.FieldEncoder) error {
	if s.Fields != nil {
		v := s.Fields

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Fields", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddValue(protocol.StringValue(v1))
		}
		ls0.End()

	}
	if len(s.Format) > 0 {
		v := s.Format

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Format", v, metadata)
	}
	return nil
}
func (s *JobManifestSpec) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = JobManifestSpec{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML JobManifestSpec.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Fields":
				if s.Fields == nil {
					s.Fields = make([]JobManifestFieldName, 0)
				}
				for {
					tok, err = d.Token()
					if tok == nil || err != nil {
						return fmt.Errorf("fail to UnmarshalAWSXML JobManifestSpec.%s, %s", name, err)
					}
					if end, ok := tok.(xml.EndElement); ok {
						name := end.Name.Local
						if name == "Fields" {
							break
						}
					}
					if start, ok := tok.(xml.StartElement); ok {
						switch name = start.Name.Local; name {
						case "member":
							tok, err = d.Token()
							if tok == nil || err != nil {
								return fmt.Errorf("fail to UnmarshalAWSXML JobManifestSpec.%s, %s", name, err)
							}
							v, _ := tok.(xml.CharData)
							value := JobManifestFieldName(v)
							s.Fields = append(s.Fields, value)
						default:
							err := d.Skip()
							if err != nil {
								return err
							}
						}
					}
				}
			case "Format":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobManifestSpec.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := JobManifestFormat(v)
				s.Format = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobManifestSpec.%s, %s", name, err)
				}
			}
		}
	}
}

// The operation that you want this job to perform on each object listed in
// the manifest. For more information about the available operations, see Available
// Operations (https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-operations.html)
// in the Amazon Simple Storage Service Developer Guide.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/JobOperation
type JobOperation struct {
	_ struct{} `type:"structure"`

	// Directs the specified job to invoke an AWS Lambda function on each object
	// in the manifest.
	LambdaInvoke *LambdaInvokeOperation `type:"structure"`

	// Directs the specified job to execute an Initiate Glacier Restore call on
	// each object in the manifest.
	S3InitiateRestoreObject *S3InitiateRestoreObjectOperation `type:"structure"`

	// Directs the specified job to execute a PUT Object acl call on each object
	// in the manifest.
	S3PutObjectAcl *S3SetObjectAclOperation `type:"structure"`

	// Directs the specified job to execute a PUT Copy object call on each object
	// in the manifest.
	S3PutObjectCopy *S3CopyObjectOperation `type:"structure"`

	// Directs the specified job to execute a PUT Object tagging call on each object
	// in the manifest.
	S3PutObjectTagging *S3SetObjectTaggingOperation `type:"structure"`
}

// String returns the string representation
func (s JobOperation) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *JobOperation) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "JobOperation"}
	if s.LambdaInvoke != nil {
		if err := s.LambdaInvoke.Validate(); err != nil {
			invalidParams.AddNested("LambdaInvoke", err.(aws.ErrInvalidParams))
		}
	}
	if s.S3PutObjectAcl != nil {
		if err := s.S3PutObjectAcl.Validate(); err != nil {
			invalidParams.AddNested("S3PutObjectAcl", err.(aws.ErrInvalidParams))
		}
	}
	if s.S3PutObjectCopy != nil {
		if err := s.S3PutObjectCopy.Validate(); err != nil {
			invalidParams.AddNested("S3PutObjectCopy", err.(aws.ErrInvalidParams))
		}
	}
	if s.S3PutObjectTagging != nil {
		if err := s.S3PutObjectTagging.Validate(); err != nil {
			invalidParams.AddNested("S3PutObjectTagging", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobOperation) MarshalFields(e protocol.FieldEncoder) error {
	if s.LambdaInvoke != nil {
		v := s.LambdaInvoke

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "LambdaInvoke", v, metadata)
	}
	if s.S3InitiateRestoreObject != nil {
		v := s.S3InitiateRestoreObject

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "S3InitiateRestoreObject", v, metadata)
	}
	if s.S3PutObjectAcl != nil {
		v := s.S3PutObjectAcl

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "S3PutObjectAcl", v, metadata)
	}
	if s.S3PutObjectCopy != nil {
		v := s.S3PutObjectCopy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "S3PutObjectCopy", v, metadata)
	}
	if s.S3PutObjectTagging != nil {
		v := s.S3PutObjectTagging

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "S3PutObjectTagging", v, metadata)
	}
	return nil
}
func (s *JobOperation) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = JobOperation{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML JobOperation.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "LambdaInvoke":
				value := LambdaInvokeOperation{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobOperation.%s, %s", name, err)
				}
				s.LambdaInvoke = &value
			case "S3InitiateRestoreObject":
				value := S3InitiateRestoreObjectOperation{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobOperation.%s, %s", name, err)
				}
				s.S3InitiateRestoreObject = &value
			case "S3PutObjectAcl":
				value := S3SetObjectAclOperation{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobOperation.%s, %s", name, err)
				}
				s.S3PutObjectAcl = &value
			case "S3PutObjectCopy":
				value := S3CopyObjectOperation{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobOperation.%s, %s", name, err)
				}
				s.S3PutObjectCopy = &value
			case "S3PutObjectTagging":
				value := S3SetObjectTaggingOperation{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobOperation.%s, %s", name, err)
				}
				s.S3PutObjectTagging = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobOperation.%s, %s", name, err)
				}
			}
		}
	}
}

// Describes the total number of tasks that the specified job has executed,
// the number of tasks that succeeded, and the number of tasks that failed.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/JobProgressSummary
type JobProgressSummary struct {
	_ struct{} `type:"structure"`

	NumberOfTasksFailed *int64 `type:"long"`

	NumberOfTasksSucceeded *int64 `type:"long"`

	TotalNumberOfTasks *int64 `type:"long"`
}

// String returns the string representation
func (s JobProgressSummary) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobProgressSummary) MarshalFields(e protocol.FieldEncoder) error {
	if s.NumberOfTasksFailed != nil {
		v := *s.NumberOfTasksFailed

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NumberOfTasksFailed", protocol.Int64Value(v), metadata)
	}
	if s.NumberOfTasksSucceeded != nil {
		v := *s.NumberOfTasksSucceeded

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "NumberOfTasksSucceeded", protocol.Int64Value(v), metadata)
	}
	if s.TotalNumberOfTasks != nil {
		v := *s.TotalNumberOfTasks

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TotalNumberOfTasks", protocol.Int64Value(v), metadata)
	}
	return nil
}
func (s *JobProgressSummary) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = JobProgressSummary{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML JobProgressSummary.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "NumberOfTasksFailed":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobProgressSummary.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.NumberOfTasksFailed = &value
			case "NumberOfTasksSucceeded":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobProgressSummary.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.NumberOfTasksSucceeded = &value
			case "TotalNumberOfTasks":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobProgressSummary.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.TotalNumberOfTasks = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobProgressSummary.%s, %s", name, err)
				}
			}
		}
	}
}

// Contains the configuration parameters for a job-completion report.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/JobReport
type JobReport struct {
	_ struct{} `type:"structure"`

	// The bucket where specified job-completion report will be stored.
	Bucket *string `min:"1" type:"string"`

	// Indicates whether the specified job will generate a job-completion report.
	//
	// Enabled is a required field
	Enabled *bool `type:"boolean" required:"true"`

	// The format of the specified job-completion report.
	Format JobReportFormat `type:"string" enum:"true"`

	// An optional prefix to describe where in the specified bucket the job-completion
	// report will be stored. Amazon S3 will store the job-completion report at
	// <prefix>/job-<job-id>/report.json.
	Prefix *string `min:"1" type:"string"`

	// Indicates whether the job-completion report will include details of all tasks
	// or only failed tasks.
	ReportScope JobReportScope `type:"string" enum:"true"`
}

// String returns the string representation
func (s JobReport) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *JobReport) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "JobReport"}
	if s.Bucket != nil && len(*s.Bucket) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Bucket", 1))
	}

	if s.Enabled == nil {
		invalidParams.Add(aws.NewErrParamRequired("Enabled"))
	}
	if s.Prefix != nil && len(*s.Prefix) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Prefix", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s JobReport) MarshalFields(e protocol.FieldEncoder) error {
	if s.Bucket != nil {
		v := *s.Bucket

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Bucket", protocol.StringValue(v), metadata)
	}
	if s.Enabled != nil {
		v := *s.Enabled

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Enabled", protocol.BoolValue(v), metadata)
	}
	if len(s.Format) > 0 {
		v := s.Format

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Format", v, metadata)
	}
	if s.Prefix != nil {
		v := *s.Prefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Prefix", protocol.StringValue(v), metadata)
	}
	if len(s.ReportScope) > 0 {
		v := s.ReportScope

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ReportScope", v, metadata)
	}
	return nil
}
func (s *JobReport) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = JobReport{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML JobReport.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Bucket":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobReport.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Bucket = &value
			case "Enabled":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobReport.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.Enabled = &value
			case "Format":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobReport.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := JobReportFormat(v)
				s.Format = value
			case "Prefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobReport.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Prefix = &value
			case "ReportScope":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobReport.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := JobReportScope(v)
				s.ReportScope = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML JobReport.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListJobStatusList(s *[]JobStatus, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]JobStatus, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []JobStatus.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := JobStatus(v)
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []JobStatus.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListJobStatusList(s *[]JobStatus, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]JobStatus, 0)
		}
	}()
	return nil
}

// Contains the configuration parameters for a Lambda Invoke operation.
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/LambdaInvokeOperation
type LambdaInvokeOperation struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) for the AWS Lambda function that the specified
	// job will invoke for each object in the manifest.
	FunctionArn *string `min:"1" type:"string"`
}

// String returns the string representation
func (s LambdaInvokeOperation) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *LambdaInvokeOperation) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "LambdaInvokeOperation"}
	if s.FunctionArn != nil && len(*s.FunctionArn) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("FunctionArn", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s LambdaInvokeOperation) MarshalFields(e protocol.FieldEncoder) error {
	if s.FunctionArn != nil {
		v := *s.FunctionArn

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "FunctionArn", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *LambdaInvokeOperation) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = LambdaInvokeOperation{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML LambdaInvokeOperation.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "FunctionArn":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LambdaInvokeOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.FunctionArn = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML LambdaInvokeOperation.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/PublicAccessBlockConfiguration
type PublicAccessBlockConfiguration struct {
	_ struct{} `type:"structure"`

	BlockPublicAcls *bool `locationName:"BlockPublicAcls" type:"boolean"`

	BlockPublicPolicy *bool `locationName:"BlockPublicPolicy" type:"boolean"`

	IgnorePublicAcls *bool `locationName:"IgnorePublicAcls" type:"boolean"`

	RestrictPublicBuckets *bool `locationName:"RestrictPublicBuckets" type:"boolean"`
}

// String returns the string representation
func (s PublicAccessBlockConfiguration) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s PublicAccessBlockConfiguration) MarshalFields(e protocol.FieldEncoder) error {
	if s.BlockPublicAcls != nil {
		v := *s.BlockPublicAcls

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BlockPublicAcls", protocol.BoolValue(v), metadata)
	}
	if s.BlockPublicPolicy != nil {
		v := *s.BlockPublicPolicy

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "BlockPublicPolicy", protocol.BoolValue(v), metadata)
	}
	if s.IgnorePublicAcls != nil {
		v := *s.IgnorePublicAcls

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "IgnorePublicAcls", protocol.BoolValue(v), metadata)
	}
	if s.RestrictPublicBuckets != nil {
		v := *s.RestrictPublicBuckets

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RestrictPublicBuckets", protocol.BoolValue(v), metadata)
	}
	return nil
}
func (s *PublicAccessBlockConfiguration) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = PublicAccessBlockConfiguration{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML PublicAccessBlockConfiguration.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "BlockPublicAcls":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML PublicAccessBlockConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.BlockPublicAcls = &value
			case "BlockPublicPolicy":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML PublicAccessBlockConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.BlockPublicPolicy = &value
			case "IgnorePublicAcls":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML PublicAccessBlockConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.IgnorePublicAcls = &value
			case "RestrictPublicBuckets":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML PublicAccessBlockConfiguration.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.RestrictPublicBuckets = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML PublicAccessBlockConfiguration.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/S3AccessControlList
type S3AccessControlList struct {
	_ struct{} `type:"structure"`

	Grants []S3Grant `type:"list"`

	// Owner is a required field
	Owner *S3ObjectOwner `type:"structure" required:"true"`
}

// String returns the string representation
func (s S3AccessControlList) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3AccessControlList) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3AccessControlList"}

	if s.Owner == nil {
		invalidParams.Add(aws.NewErrParamRequired("Owner"))
	}
	if s.Grants != nil {
		for i, v := range s.Grants {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Grants", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.Owner != nil {
		if err := s.Owner.Validate(); err != nil {
			invalidParams.AddNested("Owner", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3AccessControlList) MarshalFields(e protocol.FieldEncoder) error {
	if s.Grants != nil {
		v := s.Grants

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "Grants", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if s.Owner != nil {
		v := s.Owner

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Owner", v, metadata)
	}
	return nil
}
func (s *S3AccessControlList) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = S3AccessControlList{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML S3AccessControlList.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Grants":
				if s.Grants == nil {
					s.Grants = make([]S3Grant, 0)
				}
				err := unmarshalAWSXMLListS3GrantList(&s.Grants, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3AccessControlList.%s, %s", name, err)
				}
			case "Owner":
				value := S3ObjectOwner{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3AccessControlList.%s, %s", name, err)
				}
				s.Owner = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3AccessControlList.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/S3AccessControlPolicy
type S3AccessControlPolicy struct {
	_ struct{} `type:"structure"`

	AccessControlList *S3AccessControlList `type:"structure"`

	CannedAccessControlList S3CannedAccessControlList `type:"string" enum:"true"`
}

// String returns the string representation
func (s S3AccessControlPolicy) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3AccessControlPolicy) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3AccessControlPolicy"}
	if s.AccessControlList != nil {
		if err := s.AccessControlList.Validate(); err != nil {
			invalidParams.AddNested("AccessControlList", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3AccessControlPolicy) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccessControlList != nil {
		v := s.AccessControlList

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AccessControlList", v, metadata)
	}
	if len(s.CannedAccessControlList) > 0 {
		v := s.CannedAccessControlList

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CannedAccessControlList", v, metadata)
	}
	return nil
}
func (s *S3AccessControlPolicy) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = S3AccessControlPolicy{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML S3AccessControlPolicy.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "AccessControlList":
				value := S3AccessControlList{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3AccessControlPolicy.%s, %s", name, err)
				}
				s.AccessControlList = &value
			case "CannedAccessControlList":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3AccessControlPolicy.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := S3CannedAccessControlList(v)
				s.CannedAccessControlList = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3AccessControlPolicy.%s, %s", name, err)
				}
			}
		}
	}
}

// Contains the configuration parameters for a PUT Copy object operation. Amazon
// S3 batch operations passes each value through to the underlying PUT Copy
// object API. For more information about the parameters for this operation,
// see PUT Object - Copy (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectCOPY.html).
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/S3CopyObjectOperation
type S3CopyObjectOperation struct {
	_ struct{} `type:"structure"`

	AccessControlGrants []S3Grant `type:"list"`

	CannedAccessControlList S3CannedAccessControlList `type:"string" enum:"true"`

	MetadataDirective S3MetadataDirective `type:"string" enum:"true"`

	ModifiedSinceConstraint *time.Time `type:"timestamp"`

	NewObjectMetadata *S3ObjectMetadata `type:"structure"`

	NewObjectTagging []S3Tag `type:"list"`

	ObjectLockLegalHoldStatus S3ObjectLockLegalHoldStatus `type:"string" enum:"true"`

	ObjectLockMode S3ObjectLockMode `type:"string" enum:"true"`

	ObjectLockRetainUntilDate *time.Time `type:"timestamp"`

	RedirectLocation *string `min:"1" type:"string"`

	RequesterPays *bool `type:"boolean"`

	SSEAwsKmsKeyId *string `min:"1" type:"string"`

	StorageClass S3StorageClass `type:"string" enum:"true"`

	TargetKeyPrefix *string `min:"1" type:"string"`

	TargetResource *string `min:"1" type:"string"`

	UnModifiedSinceConstraint *time.Time `type:"timestamp"`
}

// String returns the string representation
func (s S3CopyObjectOperation) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3CopyObjectOperation) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3CopyObjectOperation"}
	if s.RedirectLocation != nil && len(*s.RedirectLocation) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("RedirectLocation", 1))
	}
	if s.SSEAwsKmsKeyId != nil && len(*s.SSEAwsKmsKeyId) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("SSEAwsKmsKeyId", 1))
	}
	if s.TargetKeyPrefix != nil && len(*s.TargetKeyPrefix) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TargetKeyPrefix", 1))
	}
	if s.TargetResource != nil && len(*s.TargetResource) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("TargetResource", 1))
	}
	if s.AccessControlGrants != nil {
		for i, v := range s.AccessControlGrants {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "AccessControlGrants", i), err.(aws.ErrInvalidParams))
			}
		}
	}
	if s.NewObjectMetadata != nil {
		if err := s.NewObjectMetadata.Validate(); err != nil {
			invalidParams.AddNested("NewObjectMetadata", err.(aws.ErrInvalidParams))
		}
	}
	if s.NewObjectTagging != nil {
		for i, v := range s.NewObjectTagging {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "NewObjectTagging", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3CopyObjectOperation) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccessControlGrants != nil {
		v := s.AccessControlGrants

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "AccessControlGrants", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.CannedAccessControlList) > 0 {
		v := s.CannedAccessControlList

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CannedAccessControlList", v, metadata)
	}
	if len(s.MetadataDirective) > 0 {
		v := s.MetadataDirective

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "MetadataDirective", v, metadata)
	}
	if s.ModifiedSinceConstraint != nil {
		v := *s.ModifiedSinceConstraint

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ModifiedSinceConstraint",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	if s.NewObjectMetadata != nil {
		v := s.NewObjectMetadata

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "NewObjectMetadata", v, metadata)
	}
	if s.NewObjectTagging != nil {
		v := s.NewObjectTagging

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "NewObjectTagging", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	if len(s.ObjectLockLegalHoldStatus) > 0 {
		v := s.ObjectLockLegalHoldStatus

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectLockLegalHoldStatus", v, metadata)
	}
	if len(s.ObjectLockMode) > 0 {
		v := s.ObjectLockMode

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectLockMode", v, metadata)
	}
	if s.ObjectLockRetainUntilDate != nil {
		v := *s.ObjectLockRetainUntilDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ObjectLockRetainUntilDate",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	if s.RedirectLocation != nil {
		v := *s.RedirectLocation

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RedirectLocation", protocol.StringValue(v), metadata)
	}
	if s.RequesterPays != nil {
		v := *s.RequesterPays

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RequesterPays", protocol.BoolValue(v), metadata)
	}
	if s.SSEAwsKmsKeyId != nil {
		v := *s.SSEAwsKmsKeyId

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SSEAwsKmsKeyId", protocol.StringValue(v), metadata)
	}
	if len(s.StorageClass) > 0 {
		v := s.StorageClass

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "StorageClass", v, metadata)
	}
	if s.TargetKeyPrefix != nil {
		v := *s.TargetKeyPrefix

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TargetKeyPrefix", protocol.StringValue(v), metadata)
	}
	if s.TargetResource != nil {
		v := *s.TargetResource

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TargetResource", protocol.StringValue(v), metadata)
	}
	if s.UnModifiedSinceConstraint != nil {
		v := *s.UnModifiedSinceConstraint

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "UnModifiedSinceConstraint",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	return nil
}
func (s *S3CopyObjectOperation) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = S3CopyObjectOperation{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "AccessControlGrants":
				if s.AccessControlGrants == nil {
					s.AccessControlGrants = make([]S3Grant, 0)
				}
				err := unmarshalAWSXMLListS3GrantList(&s.AccessControlGrants, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
			case "CannedAccessControlList":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := S3CannedAccessControlList(v)
				s.CannedAccessControlList = value
			case "MetadataDirective":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := S3MetadataDirective(v)
				s.MetadataDirective = value
			case "ModifiedSinceConstraint":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := protocol.ParseTime(protocol.ISO8601TimeFormatName, string(v))
				s.ModifiedSinceConstraint = &value
			case "NewObjectMetadata":
				value := S3ObjectMetadata{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
				s.NewObjectMetadata = &value
			case "NewObjectTagging":
				if s.NewObjectTagging == nil {
					s.NewObjectTagging = make([]S3Tag, 0)
				}
				err := unmarshalAWSXMLListS3TagSet(&s.NewObjectTagging, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
			case "ObjectLockLegalHoldStatus":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := S3ObjectLockLegalHoldStatus(v)
				s.ObjectLockLegalHoldStatus = value
			case "ObjectLockMode":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := S3ObjectLockMode(v)
				s.ObjectLockMode = value
			case "ObjectLockRetainUntilDate":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := protocol.ParseTime(protocol.ISO8601TimeFormatName, string(v))
				s.ObjectLockRetainUntilDate = &value
			case "RedirectLocation":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.RedirectLocation = &value
			case "RequesterPays":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.RequesterPays = &value
			case "SSEAwsKmsKeyId":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.SSEAwsKmsKeyId = &value
			case "StorageClass":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := S3StorageClass(v)
				s.StorageClass = value
			case "TargetKeyPrefix":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.TargetKeyPrefix = &value
			case "TargetResource":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.TargetResource = &value
			case "UnModifiedSinceConstraint":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := protocol.ParseTime(protocol.ISO8601TimeFormatName, string(v))
				s.UnModifiedSinceConstraint = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3CopyObjectOperation.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/S3Grant
type S3Grant struct {
	_ struct{} `type:"structure"`

	Grantee *S3Grantee `type:"structure"`

	Permission S3Permission `type:"string" enum:"true"`
}

// String returns the string representation
func (s S3Grant) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3Grant) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3Grant"}
	if s.Grantee != nil {
		if err := s.Grantee.Validate(); err != nil {
			invalidParams.AddNested("Grantee", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3Grant) MarshalFields(e protocol.FieldEncoder) error {
	if s.Grantee != nil {
		v := s.Grantee

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "Grantee", v, metadata)
	}
	if len(s.Permission) > 0 {
		v := s.Permission

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Permission", v, metadata)
	}
	return nil
}
func (s *S3Grant) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = S3Grant{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML S3Grant.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Grantee":
				value := S3Grantee{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Grant.%s, %s", name, err)
				}
				s.Grantee = &value
			case "Permission":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Grant.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := S3Permission(v)
				s.Permission = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Grant.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListS3GrantList(s *[]S3Grant, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]S3Grant, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := S3Grant{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []S3Grant.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []S3Grant.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListS3GrantList(s *[]S3Grant, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]S3Grant, 0)
		}
	}()
	value := S3Grant{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/S3Grantee
type S3Grantee struct {
	_ struct{} `type:"structure"`

	DisplayName *string `min:"1" type:"string"`

	Identifier *string `min:"1" type:"string"`

	TypeIdentifier S3GranteeTypeIdentifier `type:"string" enum:"true"`
}

// String returns the string representation
func (s S3Grantee) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3Grantee) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3Grantee"}
	if s.DisplayName != nil && len(*s.DisplayName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DisplayName", 1))
	}
	if s.Identifier != nil && len(*s.Identifier) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Identifier", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3Grantee) MarshalFields(e protocol.FieldEncoder) error {
	if s.DisplayName != nil {
		v := *s.DisplayName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DisplayName", protocol.StringValue(v), metadata)
	}
	if s.Identifier != nil {
		v := *s.Identifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Identifier", protocol.StringValue(v), metadata)
	}
	if len(s.TypeIdentifier) > 0 {
		v := s.TypeIdentifier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "TypeIdentifier", v, metadata)
	}
	return nil
}
func (s *S3Grantee) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = S3Grantee{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML S3Grantee.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "DisplayName":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Grantee.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.DisplayName = &value
			case "Identifier":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Grantee.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Identifier = &value
			case "TypeIdentifier":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Grantee.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := S3GranteeTypeIdentifier(v)
				s.TypeIdentifier = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Grantee.%s, %s", name, err)
				}
			}
		}
	}
}

// Contains the configuration parameters for an Initiate Glacier Restore job.
// Amazon S3 batch operations passes each value through to the underlying POST
// Object restore API. For more information about the parameters for this operation,
// see Restoring Archives (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPOSTrestore.html#RESTObjectPOSTrestore-restore-request).
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/S3InitiateRestoreObjectOperation
type S3InitiateRestoreObjectOperation struct {
	_ struct{} `type:"structure"`

	ExpirationInDays *int64 `type:"integer"`

	GlacierJobTier S3GlacierJobTier `type:"string" enum:"true"`
}

// String returns the string representation
func (s S3InitiateRestoreObjectOperation) String() string {
	return awsutil.Prettify(s)
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3InitiateRestoreObjectOperation) MarshalFields(e protocol.FieldEncoder) error {
	if s.ExpirationInDays != nil {
		v := *s.ExpirationInDays

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ExpirationInDays", protocol.Int64Value(v), metadata)
	}
	if len(s.GlacierJobTier) > 0 {
		v := s.GlacierJobTier

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "GlacierJobTier", v, metadata)
	}
	return nil
}
func (s *S3InitiateRestoreObjectOperation) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = S3InitiateRestoreObjectOperation{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML S3InitiateRestoreObjectOperation.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "ExpirationInDays":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3InitiateRestoreObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.ExpirationInDays = &value
			case "GlacierJobTier":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3InitiateRestoreObjectOperation.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := S3GlacierJobTier(v)
				s.GlacierJobTier = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3InitiateRestoreObjectOperation.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/S3ObjectMetadata
type S3ObjectMetadata struct {
	_ struct{} `type:"structure"`

	CacheControl *string `min:"1" type:"string"`

	ContentDisposition *string `min:"1" type:"string"`

	ContentEncoding *string `min:"1" type:"string"`

	ContentLanguage *string `min:"1" type:"string"`

	ContentLength *int64 `type:"long"`

	ContentMD5 *string `min:"1" type:"string"`

	ContentType *string `min:"1" type:"string"`

	HttpExpiresDate *time.Time `type:"timestamp"`

	RequesterCharged *bool `type:"boolean"`

	SSEAlgorithm S3SSEAlgorithm `type:"string" enum:"true"`

	UserMetadata map[string]string `type:"map"`
}

// String returns the string representation
func (s S3ObjectMetadata) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3ObjectMetadata) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3ObjectMetadata"}
	if s.CacheControl != nil && len(*s.CacheControl) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("CacheControl", 1))
	}
	if s.ContentDisposition != nil && len(*s.ContentDisposition) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ContentDisposition", 1))
	}
	if s.ContentEncoding != nil && len(*s.ContentEncoding) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ContentEncoding", 1))
	}
	if s.ContentLanguage != nil && len(*s.ContentLanguage) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ContentLanguage", 1))
	}
	if s.ContentMD5 != nil && len(*s.ContentMD5) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ContentMD5", 1))
	}
	if s.ContentType != nil && len(*s.ContentType) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ContentType", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3ObjectMetadata) MarshalFields(e protocol.FieldEncoder) error {
	if s.CacheControl != nil {
		v := *s.CacheControl

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "CacheControl", protocol.StringValue(v), metadata)
	}
	if s.ContentDisposition != nil {
		v := *s.ContentDisposition

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContentDisposition", protocol.StringValue(v), metadata)
	}
	if s.ContentEncoding != nil {
		v := *s.ContentEncoding

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContentEncoding", protocol.StringValue(v), metadata)
	}
	if s.ContentLanguage != nil {
		v := *s.ContentLanguage

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContentLanguage", protocol.StringValue(v), metadata)
	}
	if s.ContentLength != nil {
		v := *s.ContentLength

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContentLength", protocol.Int64Value(v), metadata)
	}
	if s.ContentMD5 != nil {
		v := *s.ContentMD5

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContentMD5", protocol.StringValue(v), metadata)
	}
	if s.ContentType != nil {
		v := *s.ContentType

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ContentType", protocol.StringValue(v), metadata)
	}
	if s.HttpExpiresDate != nil {
		v := *s.HttpExpiresDate

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "HttpExpiresDate",
			protocol.TimeValue{V: v, Format: protocol.ISO8601TimeFormatName, QuotedFormatTime: false}, metadata)
	}
	if s.RequesterCharged != nil {
		v := *s.RequesterCharged

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "RequesterCharged", protocol.BoolValue(v), metadata)
	}
	if len(s.SSEAlgorithm) > 0 {
		v := s.SSEAlgorithm

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "SSEAlgorithm", v, metadata)
	}
	if s.UserMetadata != nil {
		v := s.UserMetadata

		metadata := protocol.Metadata{}
		ms0 := e.Map(protocol.BodyTarget, "UserMetadata", metadata)
		ms0.Start()
		for k1, v1 := range v {
			ms0.MapSetValue(k1, protocol.StringValue(v1))
		}
		ms0.End()

	}
	return nil
}
func (s *S3ObjectMetadata) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = S3ObjectMetadata{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectMetadata.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "CacheControl":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectMetadata.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.CacheControl = &value
			case "ContentDisposition":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectMetadata.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ContentDisposition = &value
			case "ContentEncoding":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectMetadata.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ContentEncoding = &value
			case "ContentLanguage":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectMetadata.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ContentLanguage = &value
			case "ContentLength":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectMetadata.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseInt(string(v), 10, 64)
				s.ContentLength = &value
			case "ContentMD5":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectMetadata.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ContentMD5 = &value
			case "ContentType":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectMetadata.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ContentType = &value
			case "HttpExpiresDate":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectMetadata.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := protocol.ParseTime(protocol.ISO8601TimeFormatName, string(v))
				s.HttpExpiresDate = &value
			case "RequesterCharged":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectMetadata.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value, _ := strconv.ParseBool(string(v))
				s.RequesterCharged = &value
			case "SSEAlgorithm":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectMetadata.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := S3SSEAlgorithm(v)
				s.SSEAlgorithm = value
			case "UserMetadata":
				if s.UserMetadata == nil {
					s.UserMetadata = make(map[string]string)
				}
				curKey := ""
				for {
					tok, err := d.Token()
					if tok == nil || err != nil {
						return err
					}
					if end, ok := tok.(xml.EndElement); ok {
						name := end.Name.Local
						if name == "UserMetadata" {
							break
						}
					}
					if start, ok := tok.(xml.StartElement); ok {
						switch name = start.Name.Local; name {
						case "key":
							tok, err := d.Token()
							if tok == nil || err != nil {
								return err
							}
							v, _ := tok.(xml.CharData)
							curKey = string(v)
						case "value":
							tok, err = d.Token()
							if tok == nil || err != nil {
								return err
							}
							v, _ := tok.(xml.CharData)
							value := string(v)
							s.UserMetadata[curKey] = value
						case "entry":
							continue
						default:
							err := d.Skip()
							if err != nil {
								return err
							}
						}
					}
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectMetadata.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/S3ObjectOwner
type S3ObjectOwner struct {
	_ struct{} `type:"structure"`

	DisplayName *string `min:"1" type:"string"`

	ID *string `min:"1" type:"string"`
}

// String returns the string representation
func (s S3ObjectOwner) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3ObjectOwner) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3ObjectOwner"}
	if s.DisplayName != nil && len(*s.DisplayName) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("DisplayName", 1))
	}
	if s.ID != nil && len(*s.ID) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("ID", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3ObjectOwner) MarshalFields(e protocol.FieldEncoder) error {
	if s.DisplayName != nil {
		v := *s.DisplayName

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "DisplayName", protocol.StringValue(v), metadata)
	}
	if s.ID != nil {
		v := *s.ID

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "ID", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *S3ObjectOwner) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = S3ObjectOwner{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectOwner.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "DisplayName":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectOwner.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.DisplayName = &value
			case "ID":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectOwner.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.ID = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3ObjectOwner.%s, %s", name, err)
				}
			}
		}
	}
}

// Contains the configuration parameters for a Set Object ACL operation. Amazon
// S3 batch operations passes each value through to the underlying PUT Object
// acl API. For more information about the parameters for this operation, see
// PUT Object acl (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPUTacl.html).
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/S3SetObjectAclOperation
type S3SetObjectAclOperation struct {
	_ struct{} `type:"structure"`

	AccessControlPolicy *S3AccessControlPolicy `type:"structure"`
}

// String returns the string representation
func (s S3SetObjectAclOperation) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3SetObjectAclOperation) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3SetObjectAclOperation"}
	if s.AccessControlPolicy != nil {
		if err := s.AccessControlPolicy.Validate(); err != nil {
			invalidParams.AddNested("AccessControlPolicy", err.(aws.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3SetObjectAclOperation) MarshalFields(e protocol.FieldEncoder) error {
	if s.AccessControlPolicy != nil {
		v := s.AccessControlPolicy

		metadata := protocol.Metadata{}
		e.SetFields(protocol.BodyTarget, "AccessControlPolicy", v, metadata)
	}
	return nil
}
func (s *S3SetObjectAclOperation) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = S3SetObjectAclOperation{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML S3SetObjectAclOperation.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "AccessControlPolicy":
				value := S3AccessControlPolicy{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3SetObjectAclOperation.%s, %s", name, err)
				}
				s.AccessControlPolicy = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3SetObjectAclOperation.%s, %s", name, err)
				}
			}
		}
	}
}

// Contains the configuration parameters for a Set Object Tagging operation.
// Amazon S3 batch operations passes each value through to the underlying PUT
// Object tagging API. For more information about the parameters for this operation,
// see PUT Object tagging (https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPUTtagging.html).
// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/S3SetObjectTaggingOperation
type S3SetObjectTaggingOperation struct {
	_ struct{} `type:"structure"`

	TagSet []S3Tag `type:"list"`
}

// String returns the string representation
func (s S3SetObjectTaggingOperation) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3SetObjectTaggingOperation) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3SetObjectTaggingOperation"}
	if s.TagSet != nil {
		for i, v := range s.TagSet {
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "TagSet", i), err.(aws.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3SetObjectTaggingOperation) MarshalFields(e protocol.FieldEncoder) error {
	if s.TagSet != nil {
		v := s.TagSet

		metadata := protocol.Metadata{}
		ls0 := e.List(protocol.BodyTarget, "TagSet", metadata)
		ls0.Start()
		for _, v1 := range v {
			ls0.ListAddFields(v1)
		}
		ls0.End()

	}
	return nil
}
func (s *S3SetObjectTaggingOperation) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = S3SetObjectTaggingOperation{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML S3SetObjectTaggingOperation.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "TagSet":
				if s.TagSet == nil {
					s.TagSet = make([]S3Tag, 0)
				}
				err := unmarshalAWSXMLListS3TagSet(&s.TagSet, d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3SetObjectTaggingOperation.%s, %s", name, err)
				}
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3SetObjectTaggingOperation.%s, %s", name, err)
				}
			}
		}
	}
}

// Please also see https://docs.aws.amazon.com/goto/WebAPI/s3control-2018-08-20/S3Tag
type S3Tag struct {
	_ struct{} `type:"structure"`

	// Key is a required field
	Key *string `min:"1" type:"string" required:"true"`

	// Value is a required field
	Value *string `type:"string" required:"true"`
}

// String returns the string representation
func (s S3Tag) String() string {
	return awsutil.Prettify(s)
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *S3Tag) Validate() error {
	invalidParams := aws.ErrInvalidParams{Context: "S3Tag"}

	if s.Key == nil {
		invalidParams.Add(aws.NewErrParamRequired("Key"))
	}
	if s.Key != nil && len(*s.Key) < 1 {
		invalidParams.Add(aws.NewErrParamMinLen("Key", 1))
	}

	if s.Value == nil {
		invalidParams.Add(aws.NewErrParamRequired("Value"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// MarshalFields encodes the AWS API shape using the passed in protocol encoder.
func (s S3Tag) MarshalFields(e protocol.FieldEncoder) error {
	if s.Key != nil {
		v := *s.Key

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Key", protocol.StringValue(v), metadata)
	}
	if s.Value != nil {
		v := *s.Value

		metadata := protocol.Metadata{}
		e.SetValue(protocol.BodyTarget, "Value", protocol.StringValue(v), metadata)
	}
	return nil
}
func (s *S3Tag) unmarshalAWSXML(d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = S3Tag{}
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML S3Tag.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				return nil
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "Key":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Tag.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Key = &value
			case "Value":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Tag.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				s.Value = &value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML S3Tag.%s, %s", name, err)
				}
			}
		}
	}
}

func unmarshalAWSXMLListS3TagSet(s *[]S3Tag, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]S3Tag, 0)
		}
	}()
	name := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return err
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "member":
				value := S3Tag{}
				err := value.unmarshalAWSXML(d, start)
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []S3Tag.%s, %s", name, err)
				}
				*s = append(*s, value)
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML []S3Tag.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedListS3TagSet(s *[]S3Tag, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make([]S3Tag, 0)
		}
	}()
	value := S3Tag{}
	err = value.unmarshalAWSXML(d, head)
	if err != nil {
		return err
	}
	*s = append(*s, value)
	return nil
}

func unmarshalAWSXMLMapS3UserMetadata(s *map[string]string, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make(map[string]string)
		}
	}()
	name := ""
	curKey := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "key":
				tok, err := d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				curKey = string(v)
			case "value":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				(*s)[curKey] = value
			case "entry":
				continue
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}

func unmarshalAWSXMLFlattenedMapS3UserMetadata(s *map[string]string, d *xml.Decoder, head xml.StartElement) (err error) {
	defer func() {
		if err != nil {
			*s = make(map[string]string)
		}
	}()
	name := ""
	curKey := ""
	for {
		tok, err := d.Token()
		if tok == nil || err != nil {
			return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
		}
		if end, ok := tok.(xml.EndElement); ok {
			name = end.Name.Local
			if name == head.Name.Local {
				break
			}
		}
		if start, ok := tok.(xml.StartElement); ok {
			switch name = start.Name.Local; name {
			case "key":
				tok, err := d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				curKey = string(v)
			case "value":
				tok, err = d.Token()
				if tok == nil || err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
				}
				v, _ := tok.(xml.CharData)
				value := string(v)
				(*s)[curKey] = value
			default:
				err := d.Skip()
				if err != nil {
					return fmt.Errorf("fail to UnmarshalAWSXML map[string]string.%s, %s", name, err)
				}
			}
		}
	}
	return nil
}
